/*
 * =====================================================================================
 *
 *       Filename:  DataProcessor.cc
 *
 *    Description:  Use two interleaved zero-inflated negative binomial (NB) model to estimate
 *                  exon expression levels with sequencing bias corrected caused by non-
 *                  random starting point of each read.
 *
 *        Version:  1.0
 *        Created:  04/05/11 20:35:54
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  Jianxing Feng (), jianxing.tongji@gmail.com
 *        Company:  Tongji Univ.
 *
 * =====================================================================================
 */

#ifndef DataProcessor_H
#define DataProcessor_H

#include <stdio.h>
#include <string.h> 
#include <vector>
#include <string>
#include <iostream>
#include <fstream>
#include <sstream>
#include <map>
#include <gsl/gsl_cdf.h>
#include "Utility.hpp"
#include "GeneInfo.hpp"

using namespace std;

#define uint32 unsigned long
#define int64 long long

typedef map<string, vector<string> > string2vec_str_t;

/*
 * Transform a signature to integer
 */
inline
uint32 sig2int(const string& sig)
{
    size_t len = sig.length();
    if (len > sizeof(uint32) * 4)
    {
        cerr << __func__ << " Error, the signature length is at most " << sizeof(uint32) * 4 << endl;
        exit(1);
    }
    uint32 num = 0;
    for (size_t i = 0; i < len; ++i)
    {
        num = num << 2;
        switch(sig[i])
        {
            case 'T':
            case 't':
                num += 1; break;
            case 'C':
            case 'c':
                num += 2; break;
            case 'G':
            case 'g':
                num += 3; break;
            default:
                break;        // Treat 'N' as 'A'
        }
    }

    return num;
}


/*
 * Transform an integer to signature
 */
inline
string int2sig(int idx, int sig_len)
{
    if (sig_len > (int)sizeof(uint32) * 4)
    {
        cerr << __func__ << " Error, the signature length is at most " << sizeof(uint32) * 4 << endl;
        exit(1);
    }
    string sig = "";
    for (int i = 0; i < sig_len; ++i)
    {
        char nt = 'A';
        int curr = idx & 3;
        idx = idx >> 2;
        switch(curr)
        {
            case 0:
                nt = 'A';
                break;
            case 1:
                nt = 'T';
                break;
            case 2:
                nt = 'C';
                break;
            case 3:
                nt = 'G';
                break;
        }
        sig += nt;
    }

    return sig;
}


/*
 * Given a line generated by the data preprocessing, generate pure data
 * needed by the NB model
 *
 * [out] vector<uint32>& curr_sigs;         // The all signatures related to current segment/junction
 * [out] vector<int>& curr_reads_cnt;       // Number of mapped reads on each position of current segment/junction
 * [out] uint32& skipped_cnt;               // The number of reads skipped due to non-matched strand or partial mapping
 */
void line2pure_data(const string& a_line, int sig_len, bool b_strand_specific, vector<string>& curr_genes,
                    string& segjunc_id, vector<uint32>& curr_sigs, vector<int>& curr_reads_cnt, uint32& skipped_cnt)
{
    vector<string> fields;
    split(a_line, '\t', fields);

    split(fields[6], ',', curr_genes);

    segjunc_id = fields[3];

    const string& refseq = fields[4];
    bool b_annot_strand_positive = (fields[5][0] == '+');
    vector<string> reads_pos;
    split(fields[7], ',', reads_pos);
    vector<string> reads_strand;
    split(fields[8], ',', reads_strand);

    int refseq_len = refseq.length();
    int oneway_sig_cnt = refseq_len - sig_len + 1;

    // Thu Apr  7 11:39:25 CST 2011
    // Problem1
    // TODO: Find a best way to handle such cases.
    // It is possible that the length of this segment is too short,
    // a read is partially mapped to this segment
    if (oneway_sig_cnt <= 0)
    {
        skipped_cnt += reads_pos.size();
        curr_sigs.clear();
        curr_reads_cnt.clear();
        return;
    }

    int sig_cnt = oneway_sig_cnt;
    if (!b_strand_specific)
        sig_cnt *= 2;

    curr_sigs.resize(sig_cnt);
    for (int i = 0; i < oneway_sig_cnt; ++i)
    {
        if (b_annot_strand_positive || !b_strand_specific)
        {        
            uint32 sig = sig2int(refseq.substr(i, sig_len));
            curr_sigs[i] = sig;
        }

        if (!b_annot_strand_positive || !b_strand_specific)
        {
            string sigc = refseq.substr(i, sig_len);
            reverse (sigc.begin(), sigc.end());
            uint32 sig = sig2int(sigc);

            if (!b_annot_strand_positive && b_strand_specific)
                curr_sigs[i] = sig;
            else
                curr_sigs[i + oneway_sig_cnt] = sig;
        }
    }

    curr_reads_cnt.assign(sig_cnt, 0);
    for (unsigned i = 0; i < reads_pos.size(); ++i)
    {
        if (0 == reads_pos[i].length()) 
            continue;
        if ('#' == reads_pos[i][0] )   // In case it is place holder
            continue;
        bool b_rs_positive = !(atoi(reads_strand[i].data()) & 16);

        // If it is strand specific and the strandness does not match, this is a noise read, skip it.
        if (b_strand_specific && (b_annot_strand_positive != b_rs_positive))
        {
            ++skipped_cnt;
            continue;
        }

        // Pos related to the first nt of the refseq is 0-based.
        int pos = atoi(reads_pos[i].data());

        // Thu Apr  7 11:39:25 CST 2011
        // Problem1
        // TODO: Find a best way to handle such cases.
        // This read is mapped partially to this segment
        // Omit it.
        if (b_rs_positive && pos >= oneway_sig_cnt ||
            !b_rs_positive && pos < sig_len - 1)
        {
            ++skipped_cnt;
            continue;
        }
        if (!b_rs_positive)
        {
            pos -= sig_len - 1;
            if (!b_strand_specific)
                pos += oneway_sig_cnt;              
        }

        //continue;
        if (pos < 0 || pos >= (int)curr_reads_cnt.size())
        {
            cerr << a_line << endl;
            cerr << b_rs_positive << "," 
                 << b_strand_specific << ", " 
                 << pos << "," 
                 << oneway_sig_cnt << "," 
                 << sig_cnt << "," 
                 << pos << "," 
                 << curr_reads_cnt.size() << endl;
            LOCATION(pos);
            exit(0);
        }
        curr_reads_cnt[pos]++;
    }
}


/*
 * Analyze data generated raw data processing step and get useful information the signature length and whether the data is strand specific or not.
 */
void preAnalysis(string from_file, bool& b_strand_specific, int& seg_cnt, int& gene_cnt, int verbos_level = 0)
{
    fstream infile;
    infile.open(from_file.data(), ios::in);
    if (!infile.is_open())
    {
        cerr << "File " << from_file.data() << " can not be opened" << endl;
        exit(1);
    }

    if (verbos_level > 0)
        cerr << "-VL1 Analyzing data file " << from_file << " ..." << endl;

    int64 strand_match_cnt = 0;
    int64 strand_unmatch_cnt = 0;

    uint32 line_cnt = 0;
    string line;
    set<string> seg_ids;
    set<string> genes;

    while (getline(infile, line))
    {
        ++line_cnt;

        vector<string> fields;
        split(line, '\t', fields);

        // Check uniqueness of segment/junction ids
        string& seg_id = fields[3];
        if (seg_ids.find(seg_id) == seg_ids.end())
            seg_ids.insert(seg_id);
        else
        {
            cerr << "ERROR: Segment/junction ID " << seg_id << " appears twice." << endl;
            exit(1);
        }

        // Count number of gene ids involved.
        vector<string> curr_genes;
        split(fields[6], ',', curr_genes);
        for (size_t i = 0; i < curr_genes.size(); ++i)
            if (curr_genes[i].length() > 0)
                genes.insert(curr_genes[i]);

        // Check strandness
        bool b_strand_positive = (fields[5][0] == '+');
        vector<string> reads_strand;
        split(fields[8], ',', reads_strand);
        for (size_t i = 0; i < reads_strand.size(); ++i)
        {
            bool b_rs_positive = !(atoi(reads_strand[i].data()) & 16);
            if (b_rs_positive == b_strand_positive)
                ++strand_match_cnt;
            else
                ++strand_unmatch_cnt;
        }
    }
    seg_cnt = seg_ids.size();
    gene_cnt = genes.size();

    int64 read_cnt = strand_match_cnt + strand_unmatch_cnt;
    double port = (strand_match_cnt - (double)read_cnt / 2) / ((double)read_cnt / 4);
    double strand_pvalue = gsl_cdf_gaussian_P(port, 1);

    if (strand_pvalue < 0.0005)
        b_strand_specific = true;
    else
        b_strand_specific = false;

    if (verbos_level > 0)
    {
        cerr << "-VL1 " << line_cnt << " lines have been scanned" << endl;
        cerr << "-VL1 Analysis results: " << endl;
        cerr << "-VL1     Total read cnt = " << read_cnt << endl;
        cerr << "-VL1     Total segment/junction cnt = " << seg_cnt << endl;
        cerr << "-VL1     Total gene cnt = " << gene_cnt << endl;
        cerr << "-VL1     Strand matched read cnt = " << strand_match_cnt << endl;
        cerr << "-VL1     Strand unmatched read cnt = " << strand_unmatch_cnt << endl;
        cerr << "-VL1     P-value that the mapped reads are not strand specific = " << strand_pvalue << endl;

        if (strand_pvalue > 1e-10 && strand_pvalue < 0.0005) 
            cerr << "WARNING: mapped reads looks strange, I'm not sure about the strand specificity." << endl;
    }

    infile.close();
}

/*
 * Read data from a file and extract all the necessary information
 * [out] by_seg_signatures:  A matrix with element [i,j] be the signature of signature j of i'th segment/junction
 * [out] by_seg_read_counts: A matrix with element [i,j] be the read count of signature j of i'th segment/junction
 */
void loadSegInfo(string from_file, int sig_len, int strand_specific_code, vector<string>& all_signatures, 
                 vector<vector<uint32> >& by_seg_signatures, vector<vector<int> >& by_seg_read_counts, 
                 int verbos_level = 0)
{
    int total_seg_cnt;
    int total_gene_cnt;
    bool b_strand_specific;

    preAnalysis(from_file, b_strand_specific, total_seg_cnt, total_gene_cnt, verbos_level);

    if (strand_specific_code != 0)
    {
        bool b_strand = (strand_specific_code == 1);
        if (b_strand != b_strand_specific) 
            cerr << "WARNING: The detected strand specificity is different from the \
                     specified one (or the default one). The specified one will be used. \
                     Please double-check the data!" << endl;
    }

    by_seg_signatures.resize(total_seg_cnt);
    by_seg_read_counts.resize(total_seg_cnt);

    fstream infile;
    infile.open(from_file.data(), ios::in);
    if (!infile.is_open())
    {
        cerr << "File " << from_file.data() << " can not be opened" << endl;
        exit(1);
    }

    if (verbos_level > 0)
        cerr << "-VL1 Loading seg info from file " << from_file << " ..." << endl;

    uint32 skipped_cnt = 0;
    uint32 line_cnt = 0;
    string line;
    while (getline(infile, line))
    {
        string segjunc_id;
        vector<uint32>& curr_sigs = by_seg_signatures[line_cnt];
        vector<int>& curr_reads_cnt = by_seg_read_counts[line_cnt];
        ++line_cnt;

        if (verbos_level > 1 && line_cnt % 10000 == 0)
            cerr << "--VL2 " << line_cnt << " lines have been scanned" << endl;

        vector<string> genes;
        line2pure_data(line, sig_len, b_strand_specific, genes, segjunc_id, curr_sigs, curr_reads_cnt, skipped_cnt);
        if (0 == curr_reads_cnt.size())
            continue;
    }
    if (verbos_level > 0)
        cerr << "-VL1 " << line_cnt << " lines have been scanned" << endl;

    infile.close();

    uint32 sig_cnt = 1<<(sig_len*2);
    all_signatures.resize(sig_cnt);
    for (size_t i = 0; i < sig_cnt; ++i)
        all_signatures[i] = int2sig(i, sig_len);
}

/*
 * Read data from a file containing gene name and number of reads mapped to each gene 
 */
void loadGeneReadCounts(string from_file, vector<string>& gene_sym, vector<int>& read_counts, vector<int>& gene_length, int verbos_level = 0)
{
    fstream infile;
    infile.open(from_file.data(), ios::in);
    if (!infile.is_open())
    {
        cerr << "File " << from_file.data() << " can not be opened" << endl;
        exit(1);
    }

    if (verbos_level > 0)
        cerr << "-VL1 Loading read count for each gene from file " << from_file << " ..." << endl;

    gene_sym.resize(0);
    read_counts.resize(0);
    gene_length.resize(0);
    uint32 line_cnt = 0;
    string line;
    while (getline(infile, line))
    {
        ++line_cnt;

        vector<string> fields;
        split(line, '\t', fields);

        gene_sym.push_back(fields[0]);
        read_counts.push_back(atoi(fields[1].data()));
	gene_length.push_back(atoi(fields[2].data()));
    }

    if (verbos_level > 0)
        cerr << "-VL1 " << line_cnt << " genes have been scanned" << endl;

    infile.close();
}

/*
 * Read data from a file and extract gene seg pair information. This is a short version of readData
 */
void loadGeneSegs(string from_file, string2vec_str_t& gene_segs, vector<string>& all_seg_ids, int verbos_level = 0)
{
    fstream infile;
    infile.open(from_file.data(), ios::in);
    if (!infile.is_open())
    {
        cerr << "File " << from_file.data() << " can not be opened" << endl;
        exit(1);
    }

    if (verbos_level > 0)
        cerr << "-VL1 Loading seg/gene pairs from file " << from_file << " ..." << endl;

    all_seg_ids.resize(0);
    uint32 line_cnt = 0;
    string line;
    while (getline(infile, line))
    {
        ++line_cnt;

        vector<string> fields;
        split(line, '\t', fields);

        string& segjunc_id = fields[3];
        all_seg_ids.push_back(segjunc_id);

        vector<string> genes;
        split(fields[6], ',', genes);

        if (verbos_level > 1 && line_cnt % 100000 == 0)
            cerr << "--VL2 " << line_cnt << " lines have been scanned" << endl;

        for (size_t i = 0; i < genes.size(); ++i)
        {
            string& gene_name = genes[i];
            if (0 == gene_name.length()) 
                continue;
            if (gene_segs.find(gene_name) == gene_segs.end())
                gene_segs[gene_name] = vector<string>(); 
            gene_segs[gene_name].push_back(segjunc_id); 
        }
    }
    if (verbos_level > 0)
        cerr << "-VL1 " << line_cnt << " lines have been scanned" << endl;

    infile.close();
}

/*
 * Scan gene annotation file and get needed information
 */
void scanGPF(string from_file, GeneInfo& gene_info, int verbos_level = 0)
{
    fstream infile;
    infile.open(from_file.data(), ios::in);
    if (!infile.is_open())
    {
        cerr << "File " << from_file.data() << " can not be opened" << endl;
        exit(1);
    }

    if (verbos_level > 0)
        cerr << "-VL1 Loading gene annotation from file " << from_file << " ..." << endl;

    uint32 line_cnt = 0;
    string line;

    while (getline(infile, line))
    {
        ++line_cnt;

        vector<string> fields;
        split(line, '\t', fields);

        //string& tran_id = fields[0];
        string& chr = fields[1];
        char strand = fields[2][0];
        string& gene_id = fields[11];
        string& tran_id = fields[0];
        int exon_cnt = atoi(fields[7].data());
        vector<string> starts, ends;
        split(fields[8], ',', starts);
        split(fields[9], ',', ends);

        for (int i = 0; i < exon_cnt; ++i)
        {
            int start = atoi(starts[i].data());
            int end = atoi(ends[i].data());
            gene_info.OnAnExon(chr, strand, gene_id, tran_id, start, end);
        }
    }
    gene_info.FinishLoadingExons();

    if (verbos_level > 0)
        cerr << "-VL1 " << line_cnt << " lines have been scanned" << endl;

    infile.close();
} // scanGPF

/*
 * Scan annotation file in bed format. 
 */
void scanAnnotBED(string from_file, GeneInfo& gene_info, int verbos_level = 0)
{
    fstream infile;
    infile.open(from_file.data(), ios::in);
    if (!infile.is_open())
    {
        cerr << "File " << from_file.data() << " can not be opened" << endl;
        exit(1);
    }

    if (verbos_level > 0)
        cerr << "-VL1 Loading annotation from file " << from_file << " ..." << endl;

    uint32 line_cnt = 0;
    string line;

    while (getline(infile, line))
    {
        ++line_cnt;

        vector<string> fields;
        split(line, '\t', fields);

        //string& tran_id = fields[0];
        string& chr = fields[0];
        char strand = fields[5][0];
        string& gene_id = fields[3];
        string& tran_id = fields[3];

        int start = atoi(fields[1].data());
        int end = atoi(fields[2].data());
        gene_info.OnAnExon(chr, strand, gene_id, tran_id, start, end);
    }
    gene_info.FinishLoadingExons();

    if (verbos_level > 0)
        cerr << "-VL1 " << line_cnt << " lines have been scanned" << endl;

    infile.close();
} // scanAnnotBED

/*
 * Scan short reads in BED format and get needed information. stdin stands for standard input stream
 */
void scanReadsBED(string from_file, GeneInfo& gene_info, int verbos_level = 0)
{
    istream* p_input;
    if (from_file != "stdin")
    {
        fstream* p_infile = new fstream;
        p_infile->open(from_file.data(), ios::in);
        if (!p_infile->is_open())
        {
            cerr << "File " << from_file.data() << " can not be opened" << endl;
            exit(1);
        }
        p_input = p_infile;
    }
    else
        p_input = &cin;

    if (verbos_level > 0)
        cerr << "-VL1 Loading short reads in BED format from file " << from_file << " ..." << endl;

    uint32 line_cnt = 0;
    string line;

    gene_info.BeginLoadingShortReads();
    while (getline(*p_input, line))
    {
        ++line_cnt;

        vector<string> fields;
        split(line, '\t', fields);

        if (verbos_level > 1 && line_cnt % 50000 == 0 )
            cerr << "--VL2 " << line_cnt << " reads have been scanned. "<< endl;

        string& chr = fields[0];
        int start = atoi(fields[1].data());  
        int end = atoi(fields[2].data());  
        char strand = fields[5][0];
        int flag = ((strand == '+') ? 0 : 16);
        int read_len = end - start;

        stringstream out;
        out << read_len << "M";

        gene_info.OnAShortRead(chr, start, flag, read_len, out.str());
    }
    gene_info.FinishLoadingReads();

    if (verbos_level > 0)
        cerr << "-VL1 " << line_cnt << " reads have been scanned." << endl;

    if (from_file != "stdin")
    {
        ((fstream*)p_input)->close();
        delete p_input;
    }

} // scanReadsBED



/*
 * Scan short reads and get needed information. stdin stands for standard input stream
 */
void scanSAM(string from_file, GeneInfo& gene_info, int verbos_level = 0)
{
    istream* p_input;
    if (from_file != "stdin")
    {
        fstream* p_infile = new fstream;
        p_infile->open(from_file.data(), ios::in);
        if (!p_infile->is_open())
        {
            cerr << "File " << from_file.data() << " can not be opened" << endl;
            exit(1);
        }
        p_input = p_infile;
    }
    else
        p_input = &cin;

    if (verbos_level > 0)
        cerr << "-VL1 Loading short reads in SAM format from file " << from_file << " ..." << endl;

    uint32 line_cnt = 0;
    string line;

    gene_info.BeginLoadingShortReads();

    while (getline(*p_input, line))
    {
        ++line_cnt;
        if (line[0] == '@')
            continue;

        vector<string> fields;
        split(line, '\t', fields);

        if (verbos_level > 1 && line_cnt % 50000 == 0 )
            cerr << "--VL2 " << line_cnt << " reads have been scanned. "<< endl;

        string& chr = fields[2];
        int start = atoi(fields[3].data()) - 1;   // Note that the position in SAM format is 1-based
        int flag = atoi(fields[1].data());
        int read_len = fields[9].length();
        string& match_string = fields[5];

        gene_info.OnAShortRead(chr, start, flag, read_len, match_string);
    }
    gene_info.FinishLoadingReads();

    if (verbos_level > 0)
        cerr << "-VL1 " << line_cnt << " reads have been scanned." << endl;

    if (from_file != "stdin")
    {
        ((fstream*)p_input)->close();
        delete p_input;
    }

} // scanSAM

/*
 *--------------------------------------------------------------------------------------
 * Description:  Specify the positions and length, this method extract the sequences
 *       Param:  start_pos_of_first_nt : The position of the first neocliotide on a chromosome.
 *      Return:
 *--------------------------------------------------------------------------------------
 */
bool
scanRef(string& refseq_file, GeneInfo& gene_info, int verbos_level)
{
	// Scan the refseq, extract the required segments 
	fstream infile;
	infile.open(refseq_file.data(), ios::in);
	if (!infile.is_open())
	{
		cout << "File " << refseq_file.data() << " can not be opened" << endl;
        exit(1);
	}

    gene_info.BeginLoadingRef();
	string line;
    string chr;
	while (getline(infile, line))
	{
		if (line[0] == '>')
        {
            chr = line.substr(1, line.length()-1);
            if (verbos_level > 0)
                cerr << "-VL1 scanning refseq " << chr << " ..." << endl;
        }
        else
            gene_info.OnARefLine(chr, line);
    }

	infile.close();

	return true;
}		/* -----  end of method DataProcessor::ExtractRef  ----- */

#endif
